<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim常用快捷键</title>
      <link href="/2023/11/18/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/11/18/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>i</td><td>进入插入模式</td></tr><tr><td></td><td>…进行一些修改…</td></tr><tr><td>:wq</td><td>保存退出</td></tr></tbody></table><h1 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h1><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>ciw</td><td>删除字段并且进入插入模式</td></tr><tr><td>y</td><td>复制光标所指的字符或单词</td></tr><tr><td>yy</td><td>复制当前行</td></tr><tr><td>x</td><td>剪切光标所指的字符或单词</td></tr><tr><td>dd</td><td>剪切当前行</td></tr><tr><td>p</td><td>粘贴</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>步进（取消撤销）</td></tr><tr><td>:(行数)</td><td>前往指定行</td></tr><tr><td>G</td><td>到文件结尾</td></tr><tr><td>gg</td><td>到文件开头</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>每条路径黑节点数目一致</li><li>红节点不相邻</li></ol><h2 id="插入规则"><a href="#插入规则" class="headerlink" title="插入规则"></a>插入规则</h2><ol><li><p>如果父节点为黑，直接插入。</p></li><li><p>父叔为都红，颜色调换。</p></li><li><p>父红叔黑，颜色调换，再移动，爷爷放下来，父亲放上去。</p></li><li><p>父叔一红一黑，大脑CPU宕机…….宕机……</p></li><li><p>反正就父亲爷爷叔叔颜色反转调换，父子关系调换…….</p></li></ol><h1 id="2-7-3-学会放手"><a href="#2-7-3-学会放手" class="headerlink" title="2.7.3 学会放手"></a>2.7.3 学会放手</h1>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp多线程笔记</title>
      <link href="/2023/10/07/cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/07/cpp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string msg)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">test1</span><span class="params">(print,<span class="string">&quot;Hello C++&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数传函数名，第二个参数传参</p><p>等待子线程结束后再往下运行,join是阻塞的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test1.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>分离线程，主线程可以结束，子线程在后台可以持续运行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test1.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>判断该线程是否可以调用join或者detach，返回一个bool值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test1.<span class="built_in">joinable</span>();</span><br></pre></td></tr></table></figure><p>传引用参数时使用std::ref</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span></span><br><span class="line">std::thread <span class="built_in">t</span>(foo, std::<span class="built_in">ref</span>(a));</span><br></pre></td></tr></table></figure><p>一种写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;A::foo, a)</span></span>;</span><br></pre></td></tr></table></figure><p>我的理解是&amp;A::foo是函数指针，和函数名一致，&amp;a是函数参数对应this指针</p><h1 id="数据共享问题"><a href="#数据共享问题" class="headerlink" title="数据共享问题"></a>数据共享问题</h1><h2 id="互斥锁mutex，lock和unlock"><a href="#互斥锁mutex，lock和unlock" class="headerlink" title="互斥锁mutex，lock和unlock"></a>互斥锁mutex，lock和unlock</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="type">void</span> func_1&#123;</span><br><span class="line">    m1.<span class="built_in">lock</span>();</span><br><span class="line">    m2.<span class="built_in">lock</span>();</span><br><span class="line">    m1.<span class="built_in">unlock</span>();</span><br><span class="line">    m2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> func_2&#123;</span><br><span class="line">    m2.<span class="built_in">lock</span>();</span><br><span class="line">    m1.<span class="built_in">lock</span>();</span><br><span class="line">    m1.<span class="built_in">unlock</span>();</span><br><span class="line">    m2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br></pre></td></tr></table></figure><p>t1获取到m1之后，t2获取到m2，两个都在等待对方释放，卡死了，所以改进方案是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> func_1&#123;</span><br><span class="line">    m1.<span class="built_in">lock</span>();</span><br><span class="line">    m2.<span class="built_in">lock</span>();</span><br><span class="line">    m1.<span class="built_in">unlock</span>();</span><br><span class="line">    m2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> func_2&#123;</span><br><span class="line">    m1.<span class="built_in">lock</span>();</span><br><span class="line">    m2.<span class="built_in">lock</span>();</span><br><span class="line">    m1.<span class="built_in">unlock</span>();</span><br><span class="line">    m2.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序一致就好了</p><h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>当构造函数被调用的时候，该互斥量会被自动锁定。</p><p>当析构函数被调用时，该互斥量会自动解锁。</p><p>该对象不能被复制和移动，只能在局部作用域中使用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>相比lock_guard额外增加延迟加锁，条件变量，超时等操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::timed_mutex mtx; <span class="comment">//时间锁</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::timed_mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>; <span class="comment">//这种写法和lock_guard基础功能一致</span></span><br><span class="line"><span class="comment">//这么写不自动加锁，只是构造函数有变化，至于析构，还是自动析构的</span></span><br><span class="line"><span class="function">std::unique_lock&lt;std::timed_mutex&gt; <span class="title">ul</span><span class="params">(mtx, std::defer_lock)</span></span>; </span><br><span class="line"><span class="comment">//尝试5秒钟内加锁，5秒钟获取不到返回false，获取到了返回true</span></span><br><span class="line">ul.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">second</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="单例的线程安全问题"><a href="#单例的线程安全问题" class="headerlink" title="单例的线程安全问题"></a>单例的线程安全问题</h2><p>饿汉模式类定义的时候就实例化，本身是线程安全，不需要加锁。饿汉，就是不管三七二十一，这个类编译的时候就实例化，不考虑后面用不用得上。用法如下所示，直接在类外实例化，即初始化即实例化。</p><p>懒汉模式，就是第一次用到类的示例才实例化。注意到，前面new语句放在GetInstance函数，这个函数需要外界调用才会发挥作用，然后new一个实例。形象点记忆，懒汉就是不到万不得已就不会去实例化类，我用不上那就先不管。懒汉模式是不安全的实现方式，是线程不安全的，需要加锁。</p><p>解决1：加智能锁。不使用智能锁采用普通锁，lock()和unlock()这种加锁与解锁的方式，若空间没开辟成功直接返回，这时锁没解开就生成死锁。而智能锁不管有没有成功开辟空间，出了作用域的同时调用lock（）的析构函数把这个锁释放了，不会造成死锁。</p><p>解决2：使用原子锁。</p><p>解决3：使用once_flag</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式，每次访问的地址都是同一个，但是该不能被释放掉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">    Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *log;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Log *log;</span><br><span class="line">    <span class="built_in">Log</span>()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Log* Log::log = <span class="keyword">new</span> Log;</span><br><span class="line"><span class="comment">// 懒汉模式</span></span><br><span class="line"><span class="comment">//定义全局锁</span></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* singleton;</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Singleton的构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Singleton的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">//mtx.lock();  普通锁</span></span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mtx.unlock();</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//专门设计一个释放堆区空间的逻辑</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不要把这个逻辑放在析构函数中，将会出现无限递归</span></span><br><span class="line">        <span class="keyword">if</span>(singleton != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::singleton = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* s3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    s1-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">    s2-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">    s3-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">    Singleton::<span class="built_in">destroy</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// once_flag</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* singleton;</span><br><span class="line">    <span class="type">static</span> std::once_flag once;</span><br><span class="line">    <span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Singleton的构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Singleton的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(once, init);</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//专门设计一个释放堆区空间的逻辑</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不要把这个逻辑放在析构函数中，将会出现无限递归</span></span><br><span class="line">        <span class="keyword">if</span>(singleton != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::singleton = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="选择原则"><a href="#选择原则" class="headerlink" title="选择原则"></a>选择原则</h3><p>懒汉：在访问量比较小，采用懒汉模式。到有需要的时间才实例化对象，那它就不会提前占据内存空间，代价就是后续每次访问都会判断是否为空，增加时间成本。这是以时间换空间。</p><p>饿汉：在访问量比较大，或者可能访问的线程比较多，采用饿汉模式。就算没用上实例对象，也会进行实例化，这是要占据一定内存的。但在后面需要使用的时候，就不需要判断之类语句，所以非常快速。这就是以空间换时间。</p><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        g_queue.<span class="built_in">push</span>(i); <span class="comment">// 生产者往队列里加任务</span></span><br><span class="line">        <span class="comment">// 通知消费者来取任务</span></span><br><span class="line">        g_cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个线程去取任务</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Producer: &quot;</span>&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// 如果队列为空，就要等待</span></span><br><span class="line">        <span class="comment">// bool is_empty = g_queue.empty();</span></span><br><span class="line">        <span class="comment">// g_cv.wait(lock, !is_empty);</span></span><br><span class="line">        g_cv.<span class="built_in">wait</span>(lock, []()&#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">        g_queue.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Consumer: &quot;</span>&lt;&lt;value&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跨平台线程池"><a href="#跨平台线程池" class="headerlink" title="跨平台线程池"></a>跨平台线程池</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads):<span class="built_in">stop</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++)&#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">                    condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">                        <span class="keyword">return</span> !tasks.<span class="built_in">empty</span>()||stop;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span>(stop &amp;&amp; tasks.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; <span class="built_in">task</span>(std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>()));</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    lock.<span class="built_in">unlock</span>();</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads)&#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        函数模板里面右值引用就是万能引用，std::forward完美转发（如果是左值引用就转化成左值引用，是右值引用就转化成右值引用）。使用std::bind可以将可调用对象和参数一起绑定，绑定后的结果使用std::function进行保存，并延迟调用到任何我们需要的时候。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">        <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f,Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">            std::function&lt;<span class="type">void</span>()&gt; task = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">            &#125;</span><br><span class="line">            condition.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    pool.<span class="built_in">enqueue</span>([i]&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::<span class="built_in">second</span>(<span class="number">1</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;is done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>std::async()异步操作的线程不用自己手动创建</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future_result = std::<span class="built_in">async</span>(std::launch::async, func)</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; future_result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这种就需要，但是就有阻塞了()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> future_result = task.<span class="built_in">get_future</span>();<span class="comment">//auto的类型就是std::future&lt;int&gt;</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(std::move(task))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; future_result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>promise，线程间的数据传递</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; &amp; f)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">set_value</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    <span class="keyword">auto</span> future_result = f.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, std::ref(f))</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; future_result.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>原子变量自带线程安全，不用加锁。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; shared_data = <span class="number">0</span>;</span><br><span class="line">shared_data.<span class="built_in">load</span>();<span class="comment">//输出</span></span><br><span class="line">shared_data.<span class="built_in">store</span>();<span class="comment">//修改</span></span><br></pre></td></tr></table></figure><p>相比于加锁，效率更高，时间更短。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电赛国赛总结</title>
      <link href="/2023/08/13/%E7%94%B5%E8%B5%9B%E5%9B%BD%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/13/%E7%94%B5%E8%B5%9B%E5%9B%BD%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>草率……</p><p>荒诞……</p><p>累……</p><p>但是</p><p>学到很多</p><p>目前收获最多的竞赛</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集创赛总结</title>
      <link href="/2023/07/23/%E9%9B%86%E5%88%9B%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/23/%E9%9B%86%E5%88%9B%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>挺抽象的，没咋好好搞，但却是目前取得最理想的一个竞赛成绩。严格意义上我只投入了2天有效时间，neon加速和openmp主要也都是chatgpt帮忙写的，LIME的代码上网搜的。反正门槛确实是有的，但是怎么说呢，感觉投入还是太少了，初赛能进挺意外的，复赛（东北赛区决赛）三等奖属于意料之中和情理之中吧。</p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>其实我倒是觉得这个比赛成绩还是不太能拿出手，去了一趟大连，人生第一次见海，王老师申请经费报销差旅费，还是很感激的。另一方面就是能力的提升，结合现在正在混的互联网+竞赛，首先是学会了高效查论文，看论文，这个是最重要的一个收获。其次，学会了用openmp做一些简单的并行加速。最后，就是巩固了一下opencv。</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="/2023/05/03/C-STL/"/>
      <url>/2023/05/03/C-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="STL通用操作"><a href="#STL通用操作" class="headerlink" title="STL通用操作"></a>STL通用操作</h1><p><img src="/2023/05/03/C-STL/STL%E9%80%9A%E7%94%A8.jpg"></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="/2023/05/03/C-STL/string.jpg"></p><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p><img src="/2023/05/03/C-STL/vector.jpg"></p><h1 id="list链表"><a href="#list链表" class="headerlink" title="list链表"></a>list链表</h1><p><img src="/2023/05/03/C-STL/list1.jpg"></p><p><img src="/2023/05/03/C-STL/list2.jpg"></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><img src="/2023/05/03/C-STL/%E9%98%9F%E5%88%97.jpg"></p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img src="/2023/05/03/C-STL/%E6%A0%88.jpg"></p><h1 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h1><p><img src="/2023/05/03/C-STL/map.jpg"></p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="/2023/05/03/C-STL/set.jpg"></p><h1 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h1><p><img src="/2023/05/03/C-STL/sort.jpg"></p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><img src="/2023/05/03/C-STL/%E8%BF%AD%E4%BB%A3%E5%99%A8.jpg"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><img src="/%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令</title>
      <link href="/2023/05/02/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/02/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="最常用："><a href="#最常用：" class="headerlink" title="最常用："></a>最常用：</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 克隆远程代码下来本地</span><br><span class="line">-git clone xxxx</span><br><span class="line">// 修改的代码细节展示</span><br><span class="line">-git diff </span><br><span class="line">// 当前分支状态（改动总览）</span><br><span class="line">-git status</span><br><span class="line">// 会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，</span><br><span class="line">// 包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。(这个说法不正确，实验证明删除文件也是可以提交的)</span><br><span class="line">// git版本在2.x之后应该是把 . 和 -A作用相同化了 而不是晚上复制的</span><br><span class="line">-git add .</span><br><span class="line">-git add -A</span><br><span class="line">// 提交暂存区文件到本地仓库</span><br><span class="line">-git commit -m &quot;我的修改备注&quot;</span><br><span class="line">// 提交本地数据到 对应的远程分支</span><br><span class="line">-git push</span><br><span class="line">// 查看本地对应远程的分支对应关系</span><br><span class="line">-git branch -vv </span><br><span class="line">// 查看本地和远程所有分支</span><br><span class="line">-git branch -a </span><br><span class="line">// 以当前本地分支作为基础新建一个xxx分支（默认你这个xxx分支 也是push到 当前分支的远程分支）</span><br><span class="line">-git checkout -b xxx </span><br><span class="line">// 提交本地分支代码到 xxx远程分支</span><br><span class="line">-git push origin xxx </span><br><span class="line">// 将本地分支与远程xxx分支进行关联形成关联关系</span><br><span class="line">-git branch --set-upstream-to=origin/xxx </span><br><span class="line">// 拉取最新远程代码</span><br><span class="line">-git pull</span><br><span class="line">// 合并分支</span><br><span class="line">-git merge xxxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个是已经有的分支进行checkout</span></span><br><span class="line">-git checkout xxxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改的部分代码清理掉不修改了</span></span><br><span class="line">-git checkout .</span><br><span class="line">部分常用</span><br><span class="line">-git branch -d xxx 删除分支（当前分支不能为xxx）</span><br><span class="line">-git push origin --delete xxx(删除远程分支)</span><br><span class="line">// 文件退出暂存区，但是修改保留：</span><br><span class="line">-git reset --mixed</span><br><span class="line">// 撤销所有的已经 add 的文件：</span><br><span class="line">-git reset HEAD .</span><br><span class="line">// 撤销某个文件或文件夹：</span><br><span class="line">-git reset HEAD filename</span><br><span class="line">// 撤销commit 之后返回成暂存区add状态</span><br><span class="line">-git reset --soft HEAD^</span><br><span class="line">// 撤销commit 直接新增代码全部撤销并没有add暂存直接消失</span><br><span class="line">-git reset --hard HEAD^</span><br><span class="line">解释：</span><br><span class="line">HEAD^ 表示上一个版本，即上一次的commit，几个^代表几次提交，如果回滚两次就是HEAD^^。</span><br><span class="line">--soft</span><br><span class="line">不删除工作空间的改动代码 ，撤销commit，不撤销add</span><br><span class="line">--hard</span><br><span class="line">删除工作空间的改动代码，撤销commit且撤销add</span><br><span class="line">git stash save &quot;save tag&quot; (贮藏已经修改的代码，如果写错分支了，没有提交 可以使用，之后切换到你需要的分支进行提取出来)</span><br><span class="line">git stash list 查看贮藏的修改</span><br><span class="line">git stash pop 释放贮藏内容到当前分支</span><br><span class="line">// 多个贮藏 可以选择你需要拉取哪个贮藏</span><br><span class="line">git stash pop stash@&#123;$num&#125;</span><br><span class="line">git config --list 查看这个项目的git 配置</span><br><span class="line">git remote prune origin xxx 这个是修剪掉已经删除远程分支的本地分支</span><br><span class="line">git log 查看最近的提交信息</span><br><span class="line">git reset --hard xxxxx回退到某一个历史节点</span><br><span class="line">如果改动回到较远的一个节点 git push 可能会失败报错，因此我们需要强推到一个版本的话 需要：</span><br><span class="line">-git push -f -u // -u 这里是为了持续推送到指定分支 这里意义不大</span><br><span class="line">//下面两个命令参照这个网址 https://www.cnblogs.com/ellen-mylife/p/12794245.html</span><br><span class="line">-git rebase xxx</span><br><span class="line">-git rebase --continue</span><br></pre></td></tr></table></figure><h1 id="思考小练习（学长布置）："><a href="#思考小练习（学长布置）：" class="headerlink" title="思考小练习（学长布置）："></a>思考小练习（学长布置）：</h1><p>1、按github文档提示，生成ssh密钥对并为自己的github账号添加公钥</p><p>2、不pull仓库，不复制文件、不在github网页上传文件，用更改remote的方式把已有文件夹里的项目上传</p><p>3、手动在网页端和本地制造冲突，并在地址pull后，用记事本和git命令行将冲突合并</p><p>4、用git rebase -i合并（fixup或者squash）几个commit</p><p>5、在3基础上，试用git rebase解决冲突，看看它对commit hash（在github上看到的7位标志或者git log中看到的）的影响以及它对代码的影响</p><p>6、在4和5操作rebase前后，查看git reflog，结合《【【中文字幕】Linus 在 2007 年 Google Talk 上介绍 Git-哔哩哔哩】 <a href="https://b23.tv/UWxTL5u">https://b23.tv/UWxTL5u</a> 》理解git的存储方式</p><p>7、尝试用–amend方式修补上一个commit。并结合对4的理解，思考如何修补以前的commit，以及这两种修补带来的影响</p><p>8、用git revert逆转一个提交。说说这样做的意义</p><h1 id="推荐网页："><a href="#推荐网页：" class="headerlink" title="推荐网页："></a>推荐网页：</h1><p><a href="https://www.yiibai.com/git">https://www.yiibai.com/git</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros多机通信设置踩坑与教程</title>
      <link href="/2023/03/11/ros%E5%A4%9A%E6%9C%BA%E9%80%9A%E4%BF%A1%E8%AE%BE%E7%BD%AE%E8%B8%A9%E5%9D%91%E4%B8%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2023/03/11/ros%E5%A4%9A%E6%9C%BA%E9%80%9A%E4%BF%A1%E8%AE%BE%E7%BD%AE%E8%B8%A9%E5%9D%91%E4%B8%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本教程针对EPRobot小车开发，但对ros通信的设置也具有一定的普适性。</p><h2 id="1-确保树莓派是AP连接模式（默认是AP模式，这个一般没问题）"><a href="#1-确保树莓派是AP连接模式（默认是AP模式，这个一般没问题）" class="headerlink" title="1.确保树莓派是AP连接模式（默认是AP模式，这个一般没问题）"></a>1.确保树莓派是AP连接模式（默认是AP模式，这个一般没问题）</h2><h2 id="2-修改虚拟机home目录下的-bashrc文件，在最后附加上这段"><a href="#2-修改虚拟机home目录下的-bashrc文件，在最后附加上这段" class="headerlink" title="2.修改虚拟机home目录下的.bashrc文件，在最后附加上这段"></a>2.修改虚拟机home目录下的.bashrc文件，在最后附加上这段</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ROS_MASTER_URL=http://EPRobot:11311</span><br><span class="line">export ROS_HOSTNAME=ubuntu</span><br></pre></td></tr></table></figure><p>这段话的意思是声明主机为EPRobot，也就是我们的小车，从机为ubuntu（我们虚拟机的用户名）</p><h2 id="3-先查一下你的ip地址，运行这条指令"><a href="#3-先查一下你的ip地址，运行这条指令" class="headerlink" title="3.先查一下你的ip地址，运行这条指令"></a>3.先查一下你的ip地址，运行这条指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>inet后面的就是你的ip地址，AP模式下你的地址应该是196.168.12.xxx</p><p>实际上在=的后面，我们应该输入对应的ip地址，但是我们现在是用EPRobot和ubuntu替代了，我的理解是Ubuntu系统也有一个类似c语言宏定义的东西。在etc文件夹下有hostname和hosts这两个文件</p><p>其中，hostname里应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ubuntu</span><br></pre></td></tr></table></figure><p>hosts文件中应该有这两句话，需要对这两句进行修改</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.1.1   ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要改成你查到的ip地址</span></span><br><span class="line">192.168.12.xxx   ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认一下有没有下面这句话，没有就加上</span></span><br><span class="line">192.168.12.1 EPRobot</span><br></pre></td></tr></table></figure><p>注意：</p><p>要用root用户权限编辑etc目录下的文件，例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>如果不会用vim，就执行下面这句：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="4-我就是在下面这步踩坑了"><a href="#4-我就是在下面这步踩坑了" class="headerlink" title="4.我就是在下面这步踩坑了"></a>4.我就是在下面这步踩坑了</h2><p>其实说起来很弱智，不过确实是我疏忽大意了。<u><strong>上述的这些配置，小车也要改，呜呜呜。</strong></u></p><p>首先</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh EPRobot@192.168.12.1</span><br></pre></td></tr></table></figure><p>输入密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ncut1234</span><br></pre></td></tr></table></figure><p>然后你就能用命令行操作树莓派了，我建议大家还是学一下Linux命令行操作，有时候不得不用。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="vim的简单使用"><a href="#vim的简单使用" class="headerlink" title="vim的简单使用"></a>vim的简单使用</h4><p>按i进入insert模式（可编辑模式）</p><p>修改完之后按esc</p><p>最后输入:wq退出</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake</title>
      <link href="/2023/03/02/Cmake/"/>
      <url>/2023/03/02/Cmake/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7184793007302901820" target="_blank" >参考文档</a></p><p><a href="https://cmake.org/cmake/help/latest/" target="_blank" >官方文档</a></p><h2 id="变量的简单使用："><a href="#变量的简单使用：" class="headerlink" title="变量的简单使用："></a>变量的简单使用：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(A <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;A&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="强制使用静态链接："><a href="#强制使用静态链接：" class="headerlink" title="强制使用静态链接："></a>强制使用静态链接：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;-static&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="改可执行文件名："><a href="#改可执行文件名：" class="headerlink" title="改可执行文件名："></a>改可执行文件名：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(use_easyx main.cpp)</span><br></pre></td></tr></table></figure><h2 id="链接库："><a href="#链接库：" class="headerlink" title="链接库："></a>链接库：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(use_easyx easyx)</span><br></pre></td></tr></table></figure><h2 id="include链接目录（头文件）："><a href="#include链接目录（头文件）：" class="headerlink" title="include链接目录（头文件）："></a>include链接目录（头文件）：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h2 id="添加子项目目录："><a href="#添加子项目目录：" class="headerlink" title="添加子项目目录："></a>添加子项目目录：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>()</span><br></pre></td></tr></table></figure><h2 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">flie(GLOB <span class="keyword">TEST</span></span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/*.h&quot;</span> <span class="comment">#只是当前目录下的.h文件存到变量TEST里，不会递归查找</span></span><br><span class="line">        <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/*.cpp&quot;</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src TEST2) <span class="comment">#所有资源文件列表存到TEST2里面</span></span><br><span class="line"><span class="keyword">foreach</span>(c $(<span class="keyword">TEST</span>))</span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><h2 id="外部命令："><a href="#外部命令：" class="headerlink" title="外部命令："></a>外部命令：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> git clone https://github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line">                WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/deps/&lt;repository&gt;)</span><br></pre></td></tr></table></figure><h2 id="包管理："><a href="#包管理：" class="headerlink" title="包管理："></a>包管理：</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)<span class="comment">#引入功能模块</span></span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">        my-logger   <span class="comment">#项目名称</span></span><br><span class="line">        GIT_REPOSITORY https://github.com/ACking-you/my-logger.git <span class="comment">#仓库地址</span></span><br><span class="line">        GIT_TAG        v1.<span class="number">6.2</span>  <span class="comment">#仓库的版本tag</span></span><br><span class="line">        GIT_SHALLOW <span class="keyword">TRUE</span>    <span class="comment">#是否只拉取最新的记录</span></span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(my-logger)</span><br><span class="line"></span><br><span class="line">add_excutable(main <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="comment">#链接到程序进行使用</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main my-logger)</span><br></pre></td></tr></table></figure><p>这样引入第三方库的好处显而易见，优点类似于包管理的效果了，但缺少了最关键的中心仓库来确保资源的有效和稳定。参考golang再做个proxy层级就好了。 同样可以拉取最新的googletest可以使用下列语句：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">        googletest</span><br><span class="line">        GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">        GIT_TAG        release-<span class="number">1.12</span>.<span class="number">1</span></span><br><span class="line">        GIT_SHALLOW <span class="keyword">TRUE</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main gtest_main)</span><br></pre></td></tr></table></figure><p>vcpkg有空了解一下（备忘）</p><p>未完待续…….</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023美赛建模</title>
      <link href="/2023/02/16/2023%E7%BE%8E%E8%B5%9B%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/02/16/2023%E7%BE%8E%E8%B5%9B%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考阿里云天池大赛赛题解析</p><p><a href="https://github.com/changshanzhao/alibaba_tianchi_book" target="_blank" >源码链接点这里</a></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams.update(&#123;<span class="string">&#x27;figure.max_open_warning&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># modelling</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, RepeatedKFold, cross_val_score,cross_val_predict,KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> make_scorer,mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Lasso, Ridge, ElasticNet</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVR, SVR</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor, GradientBoostingRegressor,AdaBoostRegressor</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures,MinMaxScaler,StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = pd.read_csv(<span class="string">&#x27;x.csv&#x27;</span>)</span><br><span class="line">y = pd.read_csv(<span class="string">&#x27;y.csv&#x27;</span>)</span><br><span class="line">dif = pd.read_csv(<span class="string">&#x27;difficulty.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># normalise numeric columns</span></span><br><span class="line">cols_numeric=<span class="built_in">list</span>(x.columns)</span><br><span class="line">cols_numeric.remove(<span class="string">&#x27;Unnamed: 0&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scale_minmax</span>(<span class="params">col</span>):</span><br><span class="line">    <span class="keyword">return</span> (col-col.<span class="built_in">min</span>())/(col.<span class="built_in">max</span>()-col.<span class="built_in">min</span>())</span><br><span class="line">scale_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> cols_numeric]</span><br><span class="line">x[scale_cols] = x[scale_cols].apply(scale_minmax,axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Box-Cox</span></span><br><span class="line">cols_transform=x.columns[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols_transform:</span><br><span class="line">    <span class="comment"># transform column</span></span><br><span class="line">    x.loc[:,col], _ = stats.boxcox(x.loc[:,col]+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># split features</span></span><br><span class="line">x = x.iloc[:, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">Y = dif.iloc[:, <span class="number">1</span>]</span><br><span class="line">X = x[<span class="number">0</span>:<span class="number">355</span>]</span><br><span class="line">y = Y</span><br><span class="line">X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">100</span>)</span><br><span class="line">y_train = np.array(y_train).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y_valid = np.array(y_valid).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_data</span>():</span><br><span class="line">    df_test = x.iloc[<span class="number">355</span>]</span><br><span class="line">    df_test = np.array(df_test).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#df_test = np.delete(df_test, [0], 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> make_scorer</span><br><span class="line"></span><br><span class="line"><span class="comment"># metric for evaluation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    diff = y_pred - y_true</span><br><span class="line">    sum_sq = <span class="built_in">sum</span>(diff ** <span class="number">2</span>)</span><br><span class="line">    n = <span class="built_in">len</span>(y_pred)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(sum_sq / n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mse</span>(<span class="params">y_ture, y_pred</span>):</span><br><span class="line">    <span class="keyword">return</span> mean_squared_error(y_ture, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scorer to be used in sklearn model fitting</span></span><br><span class="line">rmse_scorer = make_scorer(rmse, greater_is_better=<span class="literal">False</span>)</span><br><span class="line">mse_scorer = make_scorer(mse, greater_is_better=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_trainning_data_omitoutliers</span>():</span><br><span class="line">    X1=X_train.copy()</span><br><span class="line">    y1=y_train.copy()</span><br><span class="line">    <span class="keyword">return</span> X1,y1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, param_grid=[], X=[], y=[], splits=<span class="number">5</span>, repeats=<span class="number">5</span></span>):</span><br><span class="line">    <span class="comment"># get unmodified training data, unless data to use already specified</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y) == <span class="number">0</span>:</span><br><span class="line">        X, y = get_trainning_data_omitoutliers()</span><br><span class="line">        <span class="comment"># poly_trans=PolynomialFeatures(degree=2)</span></span><br><span class="line">        <span class="comment"># X=poly_trans.fit_transform(X)</span></span><br><span class="line">        <span class="comment"># X=MinMaxScaler().fit_transform(X)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># create cross-validation method</span></span><br><span class="line">    rkfold = RepeatedKFold(n_splits=splits, n_repeats=repeats)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform a grid search if param_grid given</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(param_grid) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># setup grid search parameters</span></span><br><span class="line">        gsearch = GridSearchCV(model, param_grid, cv=rkfold,</span><br><span class="line">                               scoring=<span class="string">&quot;neg_mean_squared_error&quot;</span>,</span><br><span class="line">                               verbose=<span class="number">1</span>, return_train_score=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># search the grid</span></span><br><span class="line">        gsearch.fit(X, y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># extract best model from the grid</span></span><br><span class="line">        model = gsearch.best_estimator_</span><br><span class="line">        best_idx = gsearch.best_index_</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get cv-scores for best model</span></span><br><span class="line">        grid_results = pd.DataFrame(gsearch.cv_results_)</span><br><span class="line">        cv_mean = <span class="built_in">abs</span>(grid_results.loc[best_idx, <span class="string">&#x27;mean_test_score&#x27;</span>])</span><br><span class="line">        cv_std = grid_results.loc[best_idx, <span class="string">&#x27;std_test_score&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># no grid search, just cross-val score for given model</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        grid_results = []</span><br><span class="line">        cv_results = cross_val_score(model, X, y, scoring=<span class="string">&quot;neg_mean_squared_error&quot;</span>, cv=rkfold)</span><br><span class="line">        cv_mean = <span class="built_in">abs</span>(np.mean(cv_results))</span><br><span class="line">        cv_std = np.std(cv_results)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># combine mean and std cv-score in to a pandas series</span></span><br><span class="line">    cv_score = pd.Series(&#123;<span class="string">&#x27;mean&#x27;</span>: cv_mean, <span class="string">&#x27;std&#x27;</span>: cv_std&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># predict y using the fitted model</span></span><br><span class="line">    y_pred = model.predict(X).ravel()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print stats on model performance</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(model)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;score=&#x27;</span>, model.score(X, y))</span><br><span class="line">    <span class="comment"># print(&#x27;rmse=&#x27;, rmse(y, y_pred))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mse=&#x27;</span>, mse(y, y_pred))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;cross_val: mean=&#x27;</span>, cv_mean, <span class="string">&#x27;, std=&#x27;</span>, cv_std)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, cv_score, grid_results</span><br><span class="line"></span><br><span class="line"><span class="comment"># places to store optimal models and scores</span></span><br><span class="line">opt_models = <span class="built_in">dict</span>()</span><br><span class="line">score_models = pd.DataFrame(columns=[<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;std&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># no. k-fold splits</span></span><br><span class="line">splits=<span class="number">5</span></span><br><span class="line"><span class="comment"># no. k-fold iterations</span></span><br><span class="line">repeats=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">model = <span class="string">&#x27;Ridge&#x27;</span></span><br><span class="line"></span><br><span class="line">opt_models[model] = Ridge()</span><br><span class="line">alph_range = np.arange(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">0.25</span>)</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;alpha&#x27;</span>: alph_range&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model],cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=repeats)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model = <span class="string">&#x27;Lasso&#x27;</span></span><br><span class="line"></span><br><span class="line">opt_models[model] = Lasso()</span><br><span class="line">alph_range = np.arange(<span class="number">1e-4</span>,<span class="number">1e-3</span>,<span class="number">4e-5</span>)</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;alpha&#x27;</span>: alph_range&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=repeats)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model=<span class="string">&#x27;LinearSVR&#x27;</span></span><br><span class="line">opt_models[model] = LinearSVR()</span><br><span class="line"></span><br><span class="line">crange = np.arange(<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">0.1</span>)</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;C&#x27;</span>:crange,</span><br><span class="line">             <span class="string">&#x27;max_iter&#x27;</span>:[<span class="number">1000</span>]&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=repeats)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model =<span class="string">&#x27;ElasticNet&#x27;</span></span><br><span class="line">opt_models[model] = ElasticNet()</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;alpha&#x27;</span>: np.arange(<span class="number">1e-4</span>,<span class="number">1e-3</span>,<span class="number">1e-4</span>),</span><br><span class="line">              <span class="string">&#x27;l1_ratio&#x27;</span>: np.arange(<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">0.1</span>),</span><br><span class="line">              <span class="string">&#x27;max_iter&#x27;</span>:[<span class="number">100000</span>]&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model = <span class="string">&#x27;KNeighbors&#x27;</span></span><br><span class="line">opt_models[model] = KNeighborsRegressor()</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>:np.arange(<span class="number">3</span>,<span class="number">11</span>,<span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model = <span class="string">&#x27;GradientBoosting&#x27;</span></span><br><span class="line">opt_models[model] = GradientBoostingRegressor()</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_estimators&#x27;</span>:[<span class="number">150</span>,<span class="number">250</span>,<span class="number">350</span>],</span><br><span class="line">              <span class="string">&#x27;max_depth&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              <span class="string">&#x27;min_samples_split&#x27;</span>:[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]&#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score, grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line">model = <span class="string">&#x27;XGB&#x27;</span></span><br><span class="line">opt_models[model] = XGBRegressor()</span><br><span class="line"></span><br><span class="line">param_grid = &#123;<span class="string">&#x27;n_estimators&#x27;</span>:[<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>],</span><br><span class="line">              <span class="string">&#x27;max_depth&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">opt_models[model], cv_score,grid_results = train_model(opt_models[model], param_grid=param_grid,</span><br><span class="line">                                              splits=splits, repeats=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv_score.name = model</span><br><span class="line">score_models = score_models.append(cv_score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_predict</span>(<span class="params">test_data,test_y=[],stack=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment">#poly_trans=PolynomialFeatures(degree=2)</span></span><br><span class="line">    <span class="comment">#test_data1=poly_trans.fit_transform(test_data)</span></span><br><span class="line">    <span class="comment">#test_data=MinMaxScaler().fit_transform(test_data)</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    y_predict_total = np.zeros((test_data.shape[<span class="number">0</span>],))</span><br><span class="line">    <span class="keyword">for</span> model <span class="keyword">in</span> opt_models.keys():</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> model!=<span class="string">&#x27;LinearSVR&#x27;</span> <span class="keyword">and</span> model!=<span class="string">&#x27;KNeighbors&#x27;</span>:</span><br><span class="line">            y_predict=opt_models[model].predict(test_data)</span><br><span class="line">            y_predict=y_predict.ravel()</span><br><span class="line">            y_predict_total+=y_predict</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(test_y)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;_mse:&quot;</span>.<span class="built_in">format</span>(model),mean_squared_error(y_predict,test_y))</span><br><span class="line">    y_predict_mean=np.<span class="built_in">round</span>(y_predict_total/i,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(test_y)&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mean_mse:&quot;</span>,mean_squared_error(y_predict_mean,test_y))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_predict_mean=pd.Series(y_predict_mean)</span><br><span class="line">        <span class="keyword">return</span> y_predict_mean</span><br><span class="line">model_predict(X_valid,y_valid)</span><br><span class="line">df_test = x.iloc[<span class="number">355</span>]</span><br><span class="line">df_test = np.array(df_test).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">model = opt_models[<span class="string">&#x27;KNeighbors&#x27;</span>]</span><br><span class="line">res1 = model.predict(df_test)</span><br><span class="line">model = opt_models[<span class="string">&#x27;XGB&#x27;</span>]</span><br><span class="line">res2 = model.predict(df_test)</span><br><span class="line">res = (res1+res2)/<span class="number">2</span></span><br><span class="line"><span class="comment"># plot KNN</span></span><br><span class="line">x_1 = X_train.iloc[:,<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">x_2 = X_valid.iloc[:,<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">y_train = y_train.ravel()</span><br><span class="line">y_valid = y_train.ravel()</span><br><span class="line">plt.scatter(x_1,y_train,s = <span class="number">10</span>*<span class="number">10</span>,c=<span class="string">&#x27;orange&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">res1=res1.ravel()</span><br><span class="line">res1=res1[<span class="number">0</span>]</span><br><span class="line">df_test = x.iloc[<span class="number">355</span>]</span><br><span class="line">df_test = df_test.iloc[<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">plt.scatter(df_test,res1,s = <span class="number">30</span>*<span class="number">10</span>,c=<span class="string">&#x27;b&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">model = opt_models[<span class="string">&#x27;KNeighbors&#x27;</span>]</span><br><span class="line">z = model.predict(X_valid)</span><br><span class="line">z = z.ravel()</span><br><span class="line">plt.scatter(x_2,z,s = <span class="number">20</span>*<span class="number">10</span>,c=<span class="string">&#x27;k&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;KNN Regressor&#x27;</span>)</span><br><span class="line">plt.show(block=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># plot XGB</span></span><br><span class="line">x_1 = X_train.iloc[:,<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">x_2 = X_valid.iloc[:,<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">y_train = y_train.ravel()</span><br><span class="line">y_valid = y_train.ravel()</span><br><span class="line">plt.scatter(x_1,y_train,s = <span class="number">10</span>*<span class="number">10</span>,c=<span class="string">&#x27;orange&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">res2=res2.ravel()</span><br><span class="line">res2=res2[<span class="number">0</span>]</span><br><span class="line">df_test = x.iloc[<span class="number">355</span>]</span><br><span class="line">df_test = df_test.iloc[<span class="number">0</span>] <span class="comment"># 0or1</span></span><br><span class="line">plt.scatter(df_test,res2,s = <span class="number">30</span>*<span class="number">10</span>,c=<span class="string">&#x27;b&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">model = opt_models[<span class="string">&#x27;XGB&#x27;</span>]</span><br><span class="line">z = model.predict(X_valid)</span><br><span class="line">z = z.ravel()</span><br><span class="line">plt.scatter(x_2,z,s = <span class="number">20</span>*<span class="number">10</span>,c=<span class="string">&#x27;k&#x27;</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;XGB&#x27;</span>)</span><br><span class="line">plt.show(block=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">difficulty = pd.read_csv(<span class="string">&#x27;difficulty.csv&#x27;</span>)</span><br><span class="line">y = pd.read_csv(<span class="string">&#x27;y.csv&#x27;</span>)</span><br><span class="line">word = data.iloc[:,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_each_char_sort_value</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        <span class="built_in">dict</span>[i] = <span class="built_in">dict</span>.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="built_in">dict</span> = <span class="built_in">sorted</span>(<span class="built_in">dict</span>.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">355</span>):</span><br><span class="line">    x.append(count_each_char_sort_value(word[i]))</span><br><span class="line">x_pd = pd.DataFrame(x)</span><br><span class="line"></span><br><span class="line">first_char = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">355</span>):</span><br><span class="line">    first_char.append(<span class="built_in">ord</span>(word[i][<span class="number">0</span>])-<span class="number">97</span>)</span><br><span class="line"></span><br><span class="line">repeat_char = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">355</span>):</span><br><span class="line">    <span class="keyword">if</span>(x_pd.iloc[i,<span class="number">4</span>]==<span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">if</span>(x_pd.iloc[i,<span class="number">3</span>]==<span class="literal">None</span>):</span><br><span class="line">            repeat_char.append(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            repeat_char.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        repeat_char.append(<span class="number">0</span>)</span><br><span class="line">df1 = pd.DataFrame(repeat_char, columns=[<span class="string">&#x27;repeat&#x27;</span>])</span><br><span class="line">df1.insert(<span class="number">1</span>, <span class="string">&#x27;first_char&#x27;</span>, first_char,allow_duplicates = <span class="literal">False</span>)</span><br><span class="line">df1.to_csv(<span class="string">&#x27;x.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对数据进行多个模型的拟合，取拟合效果最佳的模型为所选模型</p><p>stack融合的投票机制我没搞，直接算的预测值平均值</p><p>还有一个缺点是自变量选的不好，我知道自变量的正态分布和泛化程度都不符合要求（和因变量相关性也不高），所以我也没检验，不自取其辱了，哈哈哈</p><script src="https://giscus.app/client.js"        data-repo="changshanzhao/MCM2023_zhaojb"        data-repo-id="R_kgDOI_tjsA"        data-category="General"        data-category-id="DIC_kwDOI_tjsM4CUTms"        data-mapping="url"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="preferred_color_scheme"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯备赛随笔</title>
      <link href="/2023/02/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E9%9A%8F%E7%AC%94/"/>
      <url>/2023/02/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">97</span>;i &lt; <span class="number">123</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> a = i;</span><br><span class="line">        n.<span class="built_in">push_back</span>(<span class="built_in">count</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> position = <span class="built_in">max_element</span>(n.<span class="built_in">begin</span>(),n.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n[i] == *position)</span><br><span class="line">        &#123;</span><br><span class="line">            p = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> max_char = p + <span class="number">97</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,max_char);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*position);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个比我好一点的方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 请在此输入您的代码</span></span><br><span class="line">  <span class="type">int</span> count[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;,max=<span class="number">0</span>,i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    count[ch-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count[i]&gt;count[max])</span><br><span class="line">      max=i;&#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n%d&quot;</span>,max+<span class="string">&#x27;a&#x27;</span>,count[max]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个题主要是通过加0.5巧妙实现四舍五入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> n_jige = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n_youxiu = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n_jige++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">85</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n_youxiu++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a=(n_jige*<span class="number">100.0</span>)/(n*<span class="number">1.0</span>)+<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">int</span> b=(n_youxiu*<span class="number">100.0</span>)/(n*<span class="number">1.0</span>)+<span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%\n%d%\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 987654321</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123; <span class="type">int</span> from, to, dis; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ind;              <span class="comment">// 点的序号</span></span><br><span class="line">    <span class="type">int</span> dis;              <span class="comment">// 起始点到该点的距离</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; rhs.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; edges;     <span class="comment">// 边集</span></span><br><span class="line">priority_queue&lt;node&gt; q; <span class="comment">// 小顶堆</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; lis[<span class="number">100</span>];   <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;       <span class="comment">// 起始点到所有点的最短距离</span></span><br><span class="line"><span class="type">int</span> way[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;       <span class="comment">// 路径(本题不需要)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">char</span> from,<span class="type">char</span> to,<span class="type">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(&#123;from-<span class="string">&#x27;A&#x27;</span>,to-<span class="string">&#x27;A&#x27;</span>,dis&#125;);</span><br><span class="line">    lis[from-<span class="string">&#x27;A&#x27;</span>].<span class="built_in">push_back</span>(edges.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();      <span class="comment">// 距离最小的点出队</span></span><br><span class="line">        <span class="type">int</span> ind = x.ind;</span><br><span class="line">        <span class="keyword">if</span>(x.dis!=dis[ind]) <span class="keyword">continue</span>;   <span class="comment">// 曾经出过队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lis[ind].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e=edges[lis[ind][i]];   <span class="comment">// 引用</span></span><br><span class="line">            <span class="keyword">if</span>(dis[e.to]&gt;dis[ind]+e.dis)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e.to]=dis[ind]+e.dis;</span><br><span class="line">                way[e.to]=lis[ind][i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;e.to,dis[e.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout&lt;&lt;dis[<span class="string">&#x27;S&#x27;</span>-<span class="string">&#x27;A&#x27;</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 模拟基本的加法运算过程</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 默认A.size()&gt;=B.size()</span></span><br><span class="line"><span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">t += A[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; x, y;</span><br><span class="line"><span class="comment">// 这里面102497存的是794201，倒着存方便运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">x.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">y.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans = <span class="built_in">add</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 - 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>video-test</title>
      <link href="/2023/01/29/video-test/"/>
      <url>/2023/01/29/video-test/</url>
      
        <content type="html"><![CDATA[<h2 id="本地视频测试"><a href="#本地视频测试" class="headerlink" title="本地视频测试"></a>本地视频测试</h2><p>失败….</p><h2 id="网络视频测试"><a href="#网络视频测试" class="headerlink" title="网络视频测试"></a>网络视频测试</h2><iframe src="//player.bilibili.com/player.html?aid=222464199&bvid=BV1C8411K7QY&cid=954007863&page=1&high_quality=1&danmaku=1" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe><p>在url后面加上&amp;high_quality=1&amp;danmaku=1就可以开启最高画质和弹幕<br>同时添加参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;500&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span><br></pre></td></tr></table></figure><p><strong>要是有大佬知道怎么在hexo框架下嵌入视频的话，可以在留言板教我，emm，我尝试用原生的html写，没成功</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三届MathorCup</title>
      <link href="/2023/01/29/MathorCup/"/>
      <url>/2023/01/29/MathorCup/</url>
      
        <content type="html"><![CDATA[<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">    mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    feature = <span class="string">&#x27;网络覆盖与信号强度&#x27;</span>,<span class="string">&#x27;语音通话清晰度&#x27;</span>,<span class="string">&#x27;语音通话稳定性&#x27;</span>,<span class="string">&#x27;是否遇到过网络问题&#x27;</span>,<span class="string">&#x27;居民小区&#x27;</span>,<span class="string">&#x27;办公室&#x27;</span>,<span class="string">&#x27;高校&#x27;</span>,<span class="string">&#x27;商业街&#x27;</span>,<span class="string">&#x27;地铁&#x27;</span>,<span class="string">&#x27;农村&#x27;</span>,<span class="string">&#x27;高铁&#x27;</span>,<span class="string">&#x27;其他，请注明&#x27;</span>,<span class="string">&#x27;手机没有信号&#x27;</span>,<span class="string">&#x27;有信号无法拨通&#x27;</span>,<span class="string">&#x27;通话过程中突然中断&#x27;</span>,<span class="string">&#x27;通话中有杂音、听不清、断断续续&#x27;</span>,<span class="string">&#x27;串线&#x27;</span>,<span class="string">&#x27;通话过程中一方听不见&#x27;</span>,<span class="string">&#x27;其他，请注明.1&#x27;</span>,<span class="string">&#x27;脱网次数&#x27;</span>,<span class="string">&#x27;mos质差次数&#x27;</span>,<span class="string">&#x27;未接通掉话次数&#x27;</span>,<span class="string">&#x27;重定向次数&#x27;</span>,<span class="string">&#x27;重定向驻留时长&#x27;</span>,<span class="string">&#x27;ARPU（家庭宽带）&#x27;</span>,<span class="string">&#x27;是否4G网络客户（本地剔除物联网）&#x27;</span>,<span class="string">&#x27;当月ARPU&#x27;</span>,<span class="string">&#x27;前3月ARPU&#x27;</span>,<span class="string">&#x27;当月欠费金额&#x27;</span>,<span class="string">&#x27;前第3个月欠费金额&#x27;</span></span><br><span class="line">    path = <span class="string">&#x27;f1_.csv&#x27;</span>  <span class="comment"># 数据文件路径</span></span><br><span class="line">    data = pd.read_csv(path, header=<span class="literal">None</span>)</span><br><span class="line">    x_prime = data[<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">31</span>))]</span><br><span class="line">    y = pd.Categorical(data[<span class="number">0</span>]).codes</span><br><span class="line">    x_prime_train, x_prime_test, y_train, y_test = train_test_split(x_prime, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    pairs = [c <span class="keyword">for</span> c <span class="keyword">in</span> combinations(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">31</span>), <span class="number">30</span>)]</span><br><span class="line">    feature_pairs = []</span><br><span class="line">    num = <span class="built_in">len</span>(pairs)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        feature_pairs.append(<span class="built_in">list</span>(pairs[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, pair <span class="keyword">in</span> <span class="built_in">enumerate</span>(feature_pairs):</span><br><span class="line">        <span class="comment"># 准备数据</span></span><br><span class="line">        x_train = x_prime_train[pair]</span><br><span class="line">        x_test = x_prime_test[pair]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 决策树学习</span></span><br><span class="line">        model = RandomForestClassifier(n_estimators=<span class="number">100</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>, max_depth=<span class="number">10</span>, oob_score=<span class="literal">True</span>)</span><br><span class="line">        model.fit(x_train, y_train)</span><br><span class="line">        importance = model.feature_importances_</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>,<span class="number">3</span>):</span><br><span class="line">            <span class="built_in">print</span>(feature[j], <span class="string">&#x27;:&#x27;</span>, importance[j], feature[j+<span class="number">1</span>], <span class="string">&#x27;:&#x27;</span>, importance[j+<span class="number">1</span>]</span><br><span class="line">                  , feature[j+<span class="number">2</span>], <span class="string">&#x27;:&#x27;</span>, importance[j+<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练集上的预测结果</span></span><br><span class="line">        y_train_pred = model.predict(x_train)</span><br><span class="line">        acc_train = accuracy_score(y_train, y_train_pred)</span><br><span class="line">        y_test_pred = model.predict(x_test)</span><br><span class="line">        acc_test = accuracy_score(y_test, y_test_pred)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;OOB Score:&#x27;</span>, model.oob_score_)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\t训练集准确率: %.4f%%&#x27;</span> % (<span class="number">100</span>*acc_train))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\t测试集准确率: %.4f%%\n&#x27;</span> % (<span class="number">100</span>*acc_test))</span><br></pre></td></tr></table></figure><p>importance里面有影响系数，如下：</p><p><img src="/2023/01/29/MathorCup/importance1.jpg"></p><p><img src="/2023/01/29/MathorCup/importance2.jpg"></p><p>可以看出除了前三项对整体满意度的影响较大，别的项对其影响很小。</p><p>but, 很不幸，前三项是y，不是x，大悲（）</p><p>但我头铁，死马当活马医，直接硬上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_prime = train2</span><br><span class="line">y = pd.Categorical(y2[<span class="number">3</span>]).codes</span><br><span class="line">x_prime_train, x_prime_test, y_train, y_test = train_test_split(x_prime, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">feature_pairs = [<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">51</span>))]</span><br><span class="line"><span class="keyword">for</span> i, pair <span class="keyword">in</span> <span class="built_in">enumerate</span>(feature_pairs):</span><br><span class="line">    <span class="comment"># 准备数据</span></span><br><span class="line">    x_train = x_prime_train[pair]</span><br><span class="line">    x_test = x_prime_test[pair]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 决策树学习</span></span><br><span class="line">    model = RandomForestClassifier(n_estimators=<span class="number">100</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>, max_depth=<span class="number">7</span>, oob_score=<span class="literal">True</span>)</span><br><span class="line">    model.fit(x_train, y_train)</span><br><span class="line">    y_pre = model.predict(pre2)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_pre)):</span><br><span class="line">        y_pre[j] = y_pre[j] + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>稍微小改一下，其实是一样的，就是换一下x和y</p><p>不过意料之中，准确率很低……只有50%-60%左右</p><p>然后我又尝试了一下bp神经网络</p><h2 id="BP神经网络"><a href="#BP神经网络" class="headerlink" title="BP神经网络"></a>BP神经网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0. 超参数设置</span></span><br><span class="line">lr = <span class="number">0.00002</span></span><br><span class="line">epochs = <span class="number">300</span></span><br><span class="line">n_feature = <span class="number">22</span></span><br><span class="line">n_hidden = <span class="number">300</span></span><br><span class="line">n_output = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 数据准备</span></span><br><span class="line">train1 = pd.read_csv(<span class="string">&#x27;train1_.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># train2 = pd.read_csv(&#x27;train2_.csv&#x27;, header=None)</span></span><br><span class="line"></span><br><span class="line">pre1 = pd.read_csv(<span class="string">&#x27;pre1.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># pre2 = pd.read_csv(&#x27;pre2.csv&#x27;, header=None)</span></span><br><span class="line"></span><br><span class="line">y1 = pd.read_csv(<span class="string">&#x27;f1_.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># y2 = pd.read_csv(&#x27;f2_.csv&#x27;, header=None)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_prime = train1</span><br><span class="line">y = pd.Categorical(y1[<span class="number">1</span>]).codes</span><br><span class="line">x_p_train, x_p_test, y_train, y_test = train_test_split(x_prime, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">22</span>)</span><br><span class="line">x_train = np.array(x_p_train)</span><br><span class="line">x_pre = np.array(pre1)</span><br><span class="line">x_test = np.array(x_p_test)</span><br><span class="line"></span><br><span class="line">x_train = torch.FloatTensor(x_train)</span><br><span class="line">y_train = torch.LongTensor(y_train)</span><br><span class="line">x_test = torch.FloatTensor(x_test)</span><br><span class="line">y_test = torch.LongTensor(y_test)</span><br><span class="line">x_pre = torch.FloatTensor(x_pre)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义BP神经网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bpnnModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_feature, n_hidden, n_output</span>):</span><br><span class="line">        <span class="built_in">super</span>(bpnnModel, self).__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, n_hidden)  <span class="comment"># 定义隐藏层网络</span></span><br><span class="line">        self.out = torch.nn.Linear(n_hidden, n_output)  <span class="comment"># 定义输出层网络</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = Fun.relu(self.hidden(x))  <span class="comment"># 隐藏层的激活函数,采用relu,也可以采用sigmod,tanh</span></span><br><span class="line">        out = Fun.softmax(self.out(x), dim=<span class="number">1</span>)  <span class="comment"># 输出层softmax激活函数</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义优化器损失函数</span></span><br><span class="line">net = bpnnModel(n_feature=n_feature, n_hidden=n_hidden, n_output=n_output)</span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=lr)  <span class="comment"># 优化器选用随机梯度下降方式</span></span><br><span class="line">loss_func = torch.nn.CrossEntropyLoss()  <span class="comment"># 对于多分类一般采用的交叉熵损失函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 训练数据</span></span><br><span class="line">loss_steps = np.zeros(epochs)</span><br><span class="line">accuracy_steps = np.zeros(epochs)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    y_pred = net(x_train)  <span class="comment"># 前向过程</span></span><br><span class="line">    loss = loss_func(y_pred, y_train)  <span class="comment"># 输出与label对比</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 使用梯度优化器</span></span><br><span class="line">    loss_steps[epoch] = loss.item()  <span class="comment"># 保存loss</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y_pred = net(x_test)</span><br><span class="line">    y0 = net(x_pre)</span><br><span class="line">    y = torch.argmax(y0, dim=<span class="number">1</span>)</span><br><span class="line">    correct = (torch.argmax(y_pred, dim=<span class="number">1</span>) == y_test).<span class="built_in">type</span>(torch.FloatTensor)</span><br><span class="line">    accuracy_steps[epoch] = correct.mean()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测准确率&quot;</span>, accuracy_steps[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 绘制损失函数和精度</span></span><br><span class="line">fig_name = <span class="string">&#x27;网络覆盖与信号强度(语音)&#x27;</span></span><br><span class="line">fontsize = <span class="number">15</span></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">12</span>), sharex=<span class="literal">True</span>)</span><br><span class="line">ax1.plot(accuracy_steps)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;test accuracy&quot;</span>, fontsize=fontsize)</span><br><span class="line">ax1.set_title(fig_name, fontsize=<span class="string">&#x27;xx-large&#x27;</span>)</span><br><span class="line">ax2.plot(loss_steps)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;train loss&quot;</span>, fontsize=fontsize)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;epochs&quot;</span>, fontsize=fontsize)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(fig_name + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y)):</span><br><span class="line">    y[j] = y[j] + <span class="number">1</span></span><br><span class="line">data = pd.DataFrame(y)</span><br><span class="line">data.to_csv(<span class="string">&#x27;BP网络覆盖与信号强度(语音).csv&#x27;</span>, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>emmm, 虽然准确率稍微提高了5-10个百分点，但是过拟合太严重，结果评分都是10…</p><p>算了，就这样，直接交决策树，开摆。</p><p>期待大佬留言评论。</p><p><img src="/2023/01/29/MathorCup/%E8%AF%81%E4%B9%A6.png"></p><p>意料之中，寄。</p><script src="https://giscus.app/client.js"        data-repo="changshanzhao/MathorCup"        data-repo-id="R_kgDOI2ig8w"        data-category-id="DIC_kwDOI2ig884CT3Rf"        data-mapping="url"        data-strict="0"        data-reactions-enabled="1"        data-emit-metadata="0"        data-input-position="bottom"        data-theme="preferred_color_scheme"        data-lang="zh-CN"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>images-test</title>
      <link href="/2023/01/28/images-test/"/>
      <url>/2023/01/28/images-test/</url>
      
        <content type="html"><![CDATA[<h2 id="测试图片显示"><a href="#测试图片显示" class="headerlink" title="测试图片显示"></a>测试图片显示</h2><p><img src="/2023/01/28/images-test/touxiang.jpg"></p><h2 id="测试代码块"><a href="#测试代码块" class="headerlink" title="测试代码块"></a>测试代码块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(argc, **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; argv[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/27/hello-world/"/>
      <url>/2023/01/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>本次搭建参考<a href="https://blog.museday.top/2023/01/26/blog-related/">https://blog.museday.top/2023/01/26/blog-related/</a><br>本博客仅用于记录成长</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一上总结</title>
      <link href="/2023/01/27/%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/27/%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="社科人文"><a href="#社科人文" class="headerlink" title="社科人文"></a>社科人文</h2><ol><li><p>成功当选电院14班学委</p></li><li><p>加入吉大青创，备战互联网+</p></li><li><p>微电影大赛三等奖</p></li><li><p>e天志愿者协会科技部成员</p></li><li><p>国情理论讲习班成员</p></li></ol><h2 id="科学技术"><a href="#科学技术" class="headerlink" title="科学技术"></a>科学技术</h2><ol><li>百度 apollo 自动驾驶虚拟仿真赛省二</li><li>加入吉甲大师视觉组和电控组</li><li>吉林大学机器人梦工厂人工智能方向精英队员</li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
